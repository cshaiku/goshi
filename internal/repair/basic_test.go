package repair

import (
	"testing"















































































































































































































}	}		t.Errorf("expected Actions slice to be initialized, got nil")	if plan.Actions == nil {	}		t.Errorf("expected planning to succeed, got error: %v", err)	if err != nil {	plan, err := repairer.Plan(diag)	}		Issues: []diagnose.Issue{},	diag := diagnose.Result{	repairer := &BasicRepairer{}func TestBasicRepairerPlanStructure(t *testing.T) {// TestBasicRepairerPlanStructure tests that Plan struct is properly initialized}	}		t.Errorf("expected command[1] to be 'install', got '%s'", action.Command[1])	if action.Command[1] != "install" {	}		t.Errorf("expected command[0] to be 'apt', got '%s'", action.Command[0])	if action.Command[0] != "apt" {	// Command should be apt install format	}		t.Errorf("expected non-empty Command field")	if len(action.Command) == 0 {	}		t.Errorf("expected non-empty Description field")	if action.Description == "" {	}		t.Errorf("expected non-empty Code field")	if action.Code == "" {	action := plan.Actions[0]	}		t.Errorf("expected planning to succeed, got error: %v", err)	if err != nil {	plan, err := repairer.Plan(diag)	}		},			},				Severity: diagnose.SeverityError,				Strategy: "install_git",				Message:  "binary not found: git",				Code:     "missing_binary",			{		Issues: []diagnose.Issue{	diag := diagnose.Result{	repairer := &BasicRepairer{}func TestBasicRepairerActionStructure(t *testing.T) {// TestBasicRepairerActionStructure tests that action structure is correct}	}		t.Errorf("expected install_git action, got '%s'", plan.Actions[0].Code)	if plan.Actions[0].Code != "install_git" {	}		t.Errorf("expected 1 action (only for missing binary), got %d", len(plan.Actions))	if len(plan.Actions) != 1 {	}		t.Errorf("expected planning to succeed, got error: %v", err)	if err != nil {	plan, err := repairer.Plan(diag)	}		},			},				Severity: diagnose.SeverityWarn,				Strategy: "manual_review",				Message:  "PATH has no entries",				Code:     "warning",			{			},				Severity: diagnose.SeverityError,				Strategy: "install_git",				Message:  "binary not found: git",				Code:     "missing_binary",			{		Issues: []diagnose.Issue{	diag := diagnose.Result{	repairer := &BasicRepairer{}func TestBasicRepairerMixedIssues(t *testing.T) {// TestBasicRepairerMixedIssues tests repairer with mix of missing binary and warning issues}	}		t.Errorf("expected 0 actions for warning issues, got %d", len(plan.Actions))	if len(plan.Actions) != 0 {	}		t.Errorf("expected planning to succeed, got error: %v", err)	if err != nil {	plan, err := repairer.Plan(diag)	}		},			},				Severity: diagnose.SeverityWarn,				Strategy: "manual_review",				Message:  "PATH is empty",				Code:     "warning",			{		Issues: []diagnose.Issue{	diag := diagnose.Result{	repairer := &BasicRepairer{}func TestBasicRepairerIgnoresNonMissingBinaryIssues(t *testing.T) {// TestBasicRepairerIgnoresNonMissingBinaryIssues tests that non-missing_binary issues are ignored}	}		t.Errorf("expected install_python action")	if !codes["install_python"] {	}		t.Errorf("expected install_git action")	if !codes["install_git"] {	}		codes[action.Code] = true	for _, action := range plan.Actions {	codes := map[string]bool{}	// Check that we have actions for both binaries	}		t.Errorf("expected 2 actions, got %d", len(plan.Actions))	if len(plan.Actions) != 2 {	}		t.Errorf("expected planning to succeed, got error: %v", err)	if err != nil {	plan, err := repairer.Plan(diag)	}		},			},				Severity: diagnose.SeverityError,				Strategy: "install_python",				Message:  "binary not found: python",				Code:     "missing_binary",			{			},				Severity: diagnose.SeverityError,				Strategy: "install_git",				Message:  "binary not found: git",				Code:     "missing_binary",			{		Issues: []diagnose.Issue{	diag := diagnose.Result{	repairer := &BasicRepairer{}func TestBasicRepairerMultipleMissingBinaries(t *testing.T) {// TestBasicRepairerMultipleMissingBinaries tests repairer with multiple missing binaries}	}		t.Errorf("expected non-empty command")	if len(action.Command) == 0 {	}		t.Errorf("expected non-empty description")	if action.Description == "" {	}		t.Errorf("expected action code 'install_git', got '%s'", action.Code)	if action.Code != "install_git" {	action := plan.Actions[0]	}		t.Errorf("expected 1 action, got %d", len(plan.Actions))	if len(plan.Actions) != 1 {	}		t.Errorf("expected planning to succeed, got error: %v", err)	if err != nil {	plan, err := repairer.Plan(diag)	}		},			},				Severity: diagnose.SeverityError,				Strategy: "install_git",				Message:  "binary not found: git",				Code:     "missing_binary",			{		Issues: []diagnose.Issue{	diag := diagnose.Result{	repairer := &BasicRepairer{}func TestBasicRepairerMissingBinaryIssue(t *testing.T) {// TestBasicRepairerMissingBinaryIssue tests repairer with missing binary issue}	}		t.Errorf("expected 0 actions, got %d", len(plan.Actions))	if len(plan.Actions) != 0 {	}		t.Errorf("expected empty diagnosis to succeed, got error: %v", err)	if err != nil {	plan, err := repairer.Plan(diag)	}		Issues: []diagnose.Issue{},	diag := diagnose.Result{	repairer := &BasicRepairer{}func TestBasicRepairerEmptyDiagnosis(t *testing.T) {// TestBasicRepairerEmptyDiagnosis tests repairer with empty diagnosis)	"github.com/cshaiku/goshi/internal/diagnose"