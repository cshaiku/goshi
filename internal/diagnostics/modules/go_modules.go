package modules
package modules

























































































































































































}	}		CheckTidy:           true,		CheckVulnerabilities: true,		CheckUpdates:        true,		CheckIntegrity:      true,	return &ModuleDiagnostic{func NewModuleDiagnostic() *ModuleDiagnostic {// NewModuleDiagnostic creates a diagnostic with all checks enabled}	return 0, nil	}		return 0, err	if err != nil && err.Error() != "exit status 3" {	// No vulnerabilities or other error	}		}			return 1, nil			// For now, just return that vulns were found			// Parse JSON output to count vulnerabilities		if exitErr.ExitCode() == 3 {	if exitErr, ok := err.(*exec.ExitError); ok {	// govulncheck exits with 3 if vulnerabilities found		err := cmd.Run()	cmd.Stdout = &stdout	var stdout bytes.Buffer	cmd := exec.Command("govulncheck", "-json", "./...")	}		return 0, err	if _, err := exec.LookPath("govulncheck"); err != nil {	// Check if govulncheck is installedfunc (m *ModuleDiagnostic) checkVulnerabilities() (int, error) {// checkVulnerabilities runs govulncheck if available}	return outdated, nil	}		}			outdated = append(outdated, line)		if strings.Contains(line, " [") && strings.Contains(line, "]") {		// Example: github.com/foo/bar v1.0.0 [v1.1.0]		// Lines with available updates contain " [" 	for _, line := range lines {	lines := strings.Split(stdout.String(), "\n")	var outdated []string	}		return nil, err	if err := cmd.Run(); err != nil {	cmd.Stdout = &stdout	var stdout bytes.Buffer	cmd := exec.Command("go", "list", "-u", "-m", "all")func (m *ModuleDiagnostic) checkOutdated() ([]string, error) {// checkOutdated finds outdated module dependencies}	return nil	}		return fmt.Errorf("go mod tidy would make changes")	if stdout.Len() > 0 {	// If stdout has content, changes would be made	}		return fmt.Errorf("go mod tidy would make changes")		// Non-zero means changes would be made	if err := cmd.Run(); err != nil {	// Exit code 0 means no changes needed	cmd.Stdout = &stdout	var stdout bytes.Buffer	cmd := exec.Command("go", "mod", "tidy", "-diff")	// Run go mod tidy with -diff to see if changes would be madefunc (m *ModuleDiagnostic) checkTidy() error {// checkTidy verifies go.mod and go.sum are tidy}	return nil	}		return fmt.Errorf("%w: %s", err, stderr.String())	if err := cmd.Run(); err != nil {	cmd.Stderr = &stderr	var stderr bytes.Buffer	cmd := exec.Command("go", "mod", "verify")func (m *ModuleDiagnostic) verifyModules() error {// verifyModules checks module integrity via go mod verify}	return issues	}		}			})				Strategy: "Run 'govulncheck ./...' for details and update affected packages",				Message:  fmt.Sprintf("Known vulnerabilities detected in dependencies"),				Code:     "VULN_DETECTED",				Severity: diagnose.SeverityError,			issues = append(issues, diagnose.Issue{		} else if vulns > 0 {			})				Strategy: "Install with 'go install golang.org/x/vuln/cmd/govulncheck@latest'",				Message:  "govulncheck not available for vulnerability scanning",				Code:     "VULN_CHECK_UNAVAILABLE",				Severity: diagnose.SeverityWarn,			issues = append(issues, diagnose.Issue{			// govulncheck not installed or other error		if err != nil {		vulns, err := m.checkVulnerabilities()	if m.CheckVulnerabilities {	// 4. Check for known vulnerabilities (if govulncheck available)	}		}			})				Strategy: "Run 'go get -u ./...' to update, or 'go list -u -m all' to review",				Message:  fmt.Sprintf("%d outdated dependencies found", len(outdated)),				Code:     "MOD_OUTDATED",				Severity: diagnose.SeverityWarn,			issues = append(issues, diagnose.Issue{		} else if len(outdated) > 0 {			})				Strategy: "Ensure network connectivity and try 'go list -u -m all'",				Message:  fmt.Sprintf("Unable to check for updates: %v", err),				Code:     "MOD_UPDATE_CHECK_FAILED",				Severity: diagnose.SeverityWarn,			issues = append(issues, diagnose.Issue{		if err != nil {		outdated, err := m.checkOutdated()	if m.CheckUpdates {	// 3. Check for outdated dependencies	}		}			})				Strategy: "Run 'go mod tidy' to clean up",				Message:  "go.mod/go.sum may have unused or missing dependencies",				Code:     "MOD_NOT_TIDY",				Severity: diagnose.SeverityWarn,			issues = append(issues, diagnose.Issue{		if err := m.checkTidy(); err != nil {	if m.CheckTidy {	// 2. Check if go.mod and go.sum are tidy	}		}			})				Strategy: "Run 'go mod verify' and 'go mod tidy' to fix",				Message:  fmt.Sprintf("Module integrity check failed: %v", err),				Code:     "MOD_VERIFY_FAILED",				Severity: diagnose.SeverityError,			issues = append(issues, diagnose.Issue{		if err := m.verifyModules(); err != nil {	if m.CheckIntegrity {	// 1. Verify go.sum integrity	var issues []diagnose.Issuefunc (m *ModuleDiagnostic) Run() []diagnose.Issue {// Run executes all enabled module diagnostics}	CheckTidy           bool	CheckVulnerabilities bool	CheckUpdates        bool	CheckIntegrity      booltype ModuleDiagnostic struct {// ModuleDiagnostic checks Go module health and security)	"github.com/cshaiku/goshi/internal/diagnose"	"strings"	"os/exec"	"fmt"	"bytes"import (