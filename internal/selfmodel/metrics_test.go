package selfmodel

import (
	"testing"
)



















































































































































}	}		t.Errorf("expected 2 rule lines with whitespace handling, got %d", metrics.RuleLines)	if metrics.RuleLines != 2 {	metrics := ComputeLawMetrics(raw)	raw := "  rule with spaces  \n\t\trule with tabs\t\t"func TestComputeLawMetricsWhitespace(t *testing.T) {// TestComputeLawMetricsWhitespace tests that whitespace is handled correctly}	}		t.Errorf("expected case-insensitive matching: %d vs %d", metrics1.ConstraintCount, metrics2.ConstraintCount)	if metrics1.ConstraintCount != metrics2.ConstraintCount {	metrics2 := ComputeLawMetrics(raw2)	metrics1 := ComputeLawMetrics(raw1)	raw2 := "rule: must not"	raw1 := "rule: MUST NOT"func TestComputeLawMetricsCaseSensitivity(t *testing.T) {// TestComputeLawMetricsCaseSensitivity tests that keyword matching is case-insensitive}	}		t.Errorf("expected non-negative ConstraintCount")	if metrics.ConstraintCount < 0 {	}		t.Errorf("expected non-negative RuleLines")	if metrics.RuleLines < 0 {	metrics := ComputeLawMetrics(raw)	raw := "any content"func TestComputeLawMetricsStructureInitialization(t *testing.T) {// TestComputeLawMetricsStructureInitialization tests that LawMetrics struct is initialized}	}		t.Errorf("expected positive constraint count for realistic model")	if metrics.ConstraintCount <= 0 {	}		t.Errorf("expected positive rule lines for realistic model")	if metrics.RuleLines <= 0 {	metrics := ComputeLawMetrics(raw)constraint2: refuse`constraint: neverrule2: forbidden behaviorrule1: must not violate constraints	raw := `human_greeting: Welcomefunc TestComputeLawMetricsMultilineModel(t *testing.T) {// TestComputeLawMetricsMultilineModel tests metrics on realistic model}	}		t.Errorf("expected 1 rule line (human greeting ignored), got %d", metrics.RuleLines)	if metrics.RuleLines != 1 {	metrics := ComputeLawMetrics(raw)	raw := "human_greeting: Hello there\nrule: must"func TestComputeLawMetricsHumanGreetingIgnored(t *testing.T) {// TestComputeLawMetricsHumanGreetingIgnored tests that human_greeting lines are ignored}	}		t.Errorf("expected enforcement to be active for enforcement phrase")	if !metrics.EnforcementActive {	metrics := ComputeLawMetrics(raw)	raw := "May reason about state, but it may never originate state"func TestComputeLawMetricsEnforcementDetection(t *testing.T) {// TestComputeLawMetricsEnforcementDetection tests enforcement keyword detection}	}		t.Errorf("expected at least 2 constraints in 'must never refuse', got %d", metrics.ConstraintCount)	if metrics.ConstraintCount < 2 {	metrics := ComputeLawMetrics(raw)	raw := "rule: must never refuse"func TestComputeLawMetricsMultipleConstraints(t *testing.T) {// TestComputeLawMetricsMultipleConstraints tests multiple constraints in one line}	}		})			}				t.Errorf("expected at least 1 constraint for keyword '%s', got %d", tc.keyword, metrics.ConstraintCount)			if metrics.ConstraintCount < 1 {			metrics := ComputeLawMetrics(raw)			raw := "rule: " + tc.keyword		t.Run(tc.name, func(t *testing.T) {	for _, tc := range testCases {	}		{"non-negotiable", "non-negotiable", 1},		{"forbidden", "forbidden", 1},		{"refuse", "refuse", 1},		{"never", "never", 1},		{"must", "must", 1},		{"must not", "must not", 1},	}{		expectMax int		keyword   string		name      string	testCases := []struct {func TestComputeLawMetricsConstraintDetection(t *testing.T) {// TestComputeLawMetricsConstraintDetection tests constraint keyword detection}	}		t.Errorf("expected 2 rule lines, got %d", metrics.RuleLines)	if metrics.RuleLines != 2 {	metrics := ComputeLawMetrics(raw)	raw := "rule 1\nrule 2"func TestComputeLawMetricsSimpleRule(t *testing.T) {// TestComputeLawMetricsSimpleRule tests metrics with simple rule}	}		t.Errorf("expected 0 rule lines for blank lines, got %d", metrics.RuleLines)	if metrics.RuleLines != 0 {	metrics := ComputeLawMetrics(raw)	raw := "\n\n\n"func TestComputeLawMetricsBlankLines(t *testing.T) {// TestComputeLawMetricsBlankLines tests that blank lines are ignored}	}		t.Errorf("expected enforcement to be false for empty string")	if metrics.EnforcementActive {	}		t.Errorf("expected 0 constraints for empty string, got %d", metrics.ConstraintCount)	if metrics.ConstraintCount != 0 {	}		t.Errorf("expected 0 rule lines for empty string, got %d", metrics.RuleLines)	if metrics.RuleLines != 0 {	metrics := ComputeLawMetrics("")func TestComputeLawMetricsEmpty(t *testing.T) {// TestComputeLawMetricsEmpty tests metrics calculation on empty string